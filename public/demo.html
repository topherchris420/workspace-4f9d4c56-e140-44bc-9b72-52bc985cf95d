<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R.A.I.N. Lab 3D Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #00ffff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #00ffff;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #00ffff;
        }
        
        button {
            background: #00ffff;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        button:hover {
            background: #00cccc;
        }
        
        button.active {
            background: #ff00ff;
            color: #fff;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
        }
        
        .spinner {
            border: 4px solid #333;
            border-top: 4px solid #00ffff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #quote {
            position: absolute;
            bottom: 20px;
            right: 20px;
            max-width: 400px;
            text-align: right;
            font-style: italic;
            opacity: 0.8;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div class="spinner"></div>
            <div>Initializing R.A.I.N. Lab...</div>
            <div style="font-size: 12px; margin-top: 10px;">Loading 3D Engine</div>
        </div>
        
        <div id="info">
            <h1>üß† R.A.I.N. Lab</h1>
            <p>Recursive Artificial Intelligence Nexus</p>
            <div style="margin-top: 10px; font-size: 12px;">
                <div>Apparatus: <span id="current-apparatus">Biefeld-Brown</span></div>
                <div>Phase: <span id="current-phase">Construction</span></div>
                <div>Resonance: <span id="resonance-level">0%</span></div>
            </div>
        </div>
        
        <div id="controls">
            <button id="play-pause">‚è∏Ô∏è Pause</button>
            <button id="biefeld-brown" class="active">Biefeld-Brown</button>
            <button id="flux-capacitor">Flux Capacitor</button>
            <button id="zinsser">Zinsser Module</button>
            <button id="electrokinetic-saucer">Electrokinetic Saucer</button>
        </div>
        
        <div id="quote">
            "Reality is a machine of interconnectivity and consciousness is a resonance algorithm exploring structural freedom through form."
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let currentApparatus = 'biefeld-brown';
        let currentPhase = 'construction';
        let isPlaying = true;
        let animationTime = 0;
        let apparatusGroup;
        
        // Apparatus objects
        let apparatusObjects = {};
        
        // Initialize the 3D scene
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000011, 10, 50);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxDistance = 30;
            controls.minDistance = 5;
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0x00ffff, 0.5, 100);
            pointLight.position.set(0, 10, 0);
            scene.add(pointLight);
            
            // Create apparatus group
            apparatusGroup = new THREE.Group();
            scene.add(apparatusGroup);
            
            // Initialize apparatus
            createBiefeldBrownApparatus();
            createFluxCapacitor();
            createZinsserModule();
            createElectrokineticSaucer();
            
            // Hide loading screen
            document.getElementById('loading').style.display = 'none';
            
            // Start animation
            animate();
        }
        
        // Create Biefeld-Brown Apparatus
        function createBiefeldBrownApparatus() {
            const group = new THREE.Group();
            group.visible = false;
            
            // Positive plate
            const positivePlateGeometry = new THREE.BoxGeometry(2, 3, 0.1);
            const positivePlateMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0088ff,
                emissive: 0x0044ff,
                emissiveIntensity: 0.2
            });
            const positivePlate = new THREE.Mesh(positivePlateGeometry, positivePlateMaterial);
            positivePlate.position.x = -1;
            positivePlate.castShadow = true;
            group.add(positivePlate);
            
            // Negative plate
            const negativePlateGeometry = new THREE.BoxGeometry(2, 3, 0.1);
            const negativePlateMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff4400,
                emissive: 0xff2200,
                emissiveIntensity: 0.2
            });
            const negativePlate = new THREE.Mesh(negativePlateGeometry, negativePlateMaterial);
            negativePlate.position.x = 1;
            negativePlate.castShadow = true;
            group.add(negativePlate);
            
            // Dielectric
            const dielectricGeometry = new THREE.BoxGeometry(1.5, 2.5, 0.5);
            const dielectricMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x44ff44,
                transparent: true,
                opacity: 0.6
            });
            const dielectric = new THREE.Mesh(dielectricGeometry, dielectricMaterial);
            dielectric.position.z = 0.5;
            group.add(dielectric);
            
            // Field lines
            const fieldLineGeometry = new THREE.BufferGeometry();
            const fieldLinePositions = [];
            
            for (let i = 0; i < 20; i++) {
                const y = (i / 19) * 4 - 2;
                fieldLinePositions.push(-1, y, 0);
                fieldLinePositions.push(1, y, 0);
            }
            
            fieldLineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(fieldLinePositions, 3));
            const fieldLineMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ffff,
                transparent: true,
                opacity: 0.5
            });
            const fieldLines = new THREE.LineSegments(fieldLineGeometry, fieldLineMaterial);
            group.add(fieldLines);
            
            apparatusObjects['biefeld-brown'] = group;
            apparatusGroup.add(group);
        }
        
        // Create Flux Capacitor
        function createFluxCapacitor() {
            const group = new THREE.Group();
            group.visible = false;
            
            // Main capacitor
            const capacitorGeometry = new THREE.CylinderGeometry(1, 1, 0.5, 32);
            const capacitorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff00ff,
                emissive: 0xff00ff,
                emissiveIntensity: 0.3
            });
            const capacitor = new THREE.Mesh(capacitorGeometry, capacitorMaterial);
            capacitor.rotation.z = Math.PI / 2;
            group.add(capacitor);
            
            // Pulse rings
            for (let i = 0; i < 3; i++) {
                const ringGeometry = new THREE.TorusGeometry(1.5 + i * 0.3, 0.05, 8, 32);
                const ringMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.5
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                ring.position.z = (i - 1) * 0.5;
                group.add(ring);
            }
            
            // Energy spheres
            for (let i = 0; i < 8; i++) {
                const sphereGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const sphereMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffff00,
                    emissive: 0xffff00,
                    emissiveIntensity: 1
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                const angle = (i / 8) * Math.PI * 2;
                sphere.position.x = Math.cos(angle) * 2;
                sphere.position.y = Math.sin(angle) * 2;
                group.add(sphere);
            }
            
            apparatusObjects['flux-capacitor'] = group;
            apparatusGroup.add(group);
        }
        
        // Create Zinsser Module
        function createZinsserModule() {
            const group = new THREE.Group();
            group.visible = false;
            
            // Water container
            const containerGeometry = new THREE.BoxGeometry(2, 2, 1);
            const containerMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0088ff,
                transparent: true,
                opacity: 0.3
            });
            const container = new THREE.Mesh(containerGeometry, containerMaterial);
            group.add(container);
            
            // Electrode plates
            for (let i = 0; i < 2; i++) {
                const plateGeometry = new THREE.BoxGeometry(1.8, 1.8, 0.05);
                const plateMaterial = new THREE.MeshStandardMaterial({ 
                    color: i === 0 ? 0xff0000 : 0x0000ff,
                    emissive: i === 0 ? 0xff0000 : 0x0000ff,
                    emissiveIntensity: 0.2
                });
                const plate = new THREE.Mesh(plateGeometry, plateMaterial);
                plate.position.z = (i - 0.5) * 0.8;
                group.add(plate);
            }
            
            // Force field lines
            const fieldGeometry = new THREE.BufferGeometry();
            const fieldPositions = [];
            
            for (let i = 0; i < 10; i++) {
                const x = (i / 9) * 3 - 1.5;
                for (let j = 0; j < 10; j++) {
                    const y = (j / 9) * 3 - 1.5;
                    fieldPositions.push(x, y, 0);
                    fieldPositions.push(x, y, 1);
                }
            }
            
            fieldGeometry.setAttribute('position', new THREE.Float32BufferAttribute(fieldPositions, 3));
            const fieldMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ff00,
                transparent: true,
                opacity: 0.3
            });
            const fieldLines = new THREE.LineSegments(fieldGeometry, fieldMaterial);
            group.add(fieldLines);
            
            apparatusObjects['zinsser'] = group;
            apparatusGroup.add(group);
        }
        
        // Create Electrokinetic Saucer
        function createElectrokineticSaucer() {
            const group = new THREE.Group();
            group.visible = false;
            
            // Saucer body
            const saucerGeometry = new THREE.CylinderGeometry(2, 1.5, 0.3, 32);
            const saucerMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x888888,
                emissive: 0x444444,
                emissiveIntensity: 0.1
            });
            const saucer = new THREE.Mesh(saucerGeometry, saucerMaterial);
            group.add(saucer);
            
            // Distributor cap
            const capGeometry = new THREE.CylinderGeometry(0.5, 0.3, 0.2, 16);
            const capMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff00ff,
                emissive: 0xff00ff,
                emissiveIntensity: 0.5
            });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 0.25;
            group.add(cap);
            
            // Capacitor sections
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const sectionGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.8);
                const sectionMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.3
                });
                const section = new THREE.Mesh(sectionGeometry, sectionMaterial);
                section.position.x = Math.cos(angle) * 1.2;
                section.position.z = Math.sin(angle) * 1.2;
                section.rotation.y = angle;
                group.add(section);
            }
            
            apparatusObjects['electrokinetic-saucer'] = group;
            apparatusGroup.add(group);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (isPlaying) {
                animationTime += 0.016; // ~60fps
                
                // Update current apparatus
                const apparatus = apparatusObjects[currentApparatus];
                if (apparatus) {
                    // Hide all apparatus
                    Object.values(apparatusObjects).forEach(obj => obj.visible = false);
                    
                    // Show current apparatus
                    apparatus.visible = true;
                    
                    // Animate based on apparatus type
                    switch (currentApparatus) {
                        case 'biefeld-brown':
                            animateBiefeldBrown(apparatus);
                            break;
                        case 'flux-capacitor':
                            animateFluxCapacitor(apparatus);
                            break;
                        case 'zinsser':
                            animateZinsserModule(apparatus);
                            break;
                        case 'electrokinetic-saucer':
                            animateElectrokineticSaucer(apparatus);
                            break;
                    }
                }
                
                // Update UI
                updateUI();
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Animate Biefeld-Brown Apparatus
        function animateBiefeldBrown(apparatus) {
            const resonance = Math.sin(animationTime * 2) * 0.5 + 0.5;
            const voltage = Math.sin(animationTime * 5) * 0.5 + 0.5;
            
            // Animate plates
            if (apparatus.children[0]) {
                apparatus.children[0].material.emissiveIntensity = voltage * 0.5;
            }
            if (apparatus.children[1]) {
                apparatus.children[1].material.emissiveIntensity = voltage * 0.5;
            }
            
            // Animate dielectric
            if (apparatus.children[2]) {
                apparatus.children[2].scale.setScalar(1 + resonance * 0.1);
            }
            
            // Animate field lines
            if (apparatus.children[3]) {
                apparatus.children[3].material.opacity = 0.3 + voltage * 0.4;
            }
        }
        
        // Animate Flux Capacitor
        function animateFluxCapacitor(apparatus) {
            const resonance = Math.sin(animationTime * 3) * 0.5 + 0.5;
            const voltage = Math.sin(animationTime * 8) * 0.5 + 0.5;
            
            // Animate main capacitor
            if (apparatus.children[0]) {
                apparatus.children[0].material.emissiveIntensity = voltage * 0.8;
                apparatus.children[0].scale.setScalar(1 + resonance * 0.2);
            }
            
            // Animate pulse rings
            for (let i = 1; i <= 3; i++) {
                if (apparatus.children[i]) {
                    const phase = animationTime * 10 + i * 0.5;
                    apparatus.children[i].material.emissiveIntensity = Math.sin(phase) * resonance;
                    apparatus.children[i].scale.setScalar(1 + Math.sin(phase) * 0.3);
                }
            }
            
            // Animate energy spheres
            for (let i = 4; i < 12; i++) {
                if (apparatus.children[i]) {
                    const angle = animationTime * 2 + (i - 4) * 0.785;
                    const radius = 2 + Math.sin(animationTime * 5 + i) * 0.5;
                    apparatus.children[i].position.x = Math.cos(angle) * radius;
                    apparatus.children[i].position.y = Math.sin(angle) * radius;
                    apparatus.children[i].material.emissiveIntensity = resonance;
                }
            }
        }
        
        // Animate Zinsser Module
        function animateZinsserModule(apparatus) {
            const resonance = Math.sin(animationTime * 4) * 0.5 + 0.5;
            const voltage = Math.sin(animationTime * 12) * 0.5 + 0.5;
            
            // Animate water container
            if (apparatus.children[0]) {
                apparatus.children[0].material.opacity = 0.3 + Math.sin(animationTime * 20) * 0.1 * resonance;
                apparatus.children[0].scale.setScalar(1 + resonance * 0.1);
            }
            
            // Animate electrode plates
            for (let i = 1; i <= 2; i++) {
                if (apparatus.children[i]) {
                    const phase = animationTime * 20 + (i - 1) * Math.PI;
                    apparatus.children[i].material.emissiveIntensity = Math.sin(phase) * voltage * resonance;
                }
            }
            
            // Animate force field
            if (apparatus.children[3]) {
                apparatus.children[3].material.opacity = 0.3 + resonance * 0.4;
            }
        }
        
        // Animate Electrokinetic Saucer
        function animateElectrokineticSaucer(apparatus) {
            const resonance = Math.sin(animationTime * 2.5) * 0.5 + 0.5;
            const voltage = Math.sin(animationTime * 15) * 0.5 + 0.5;
            
            // Animate saucer body
            if (apparatus.children[0]) {
                apparatus.children[0].material.emissiveIntensity = voltage * 0.3;
                apparatus.children[0].scale.setScalar(1 + resonance * 0.05);
            }
            
            // Animate distributor cap
            if (apparatus.children[1]) {
                apparatus.children[1].rotation.y = animationTime * 10;
                apparatus.children[1].material.emissiveIntensity = Math.sin(animationTime * 30) < 0.1 ? resonance : 0;
            }
            
            // Animate capacitor sections
            for (let i = 2; i < 10; i++) {
                if (apparatus.children[i]) {
                    const chargePhase = (animationTime * 5 + (i - 2) * 0.1) % 1;
                    const chargeIntensity = Math.sin(chargePhase * Math.PI) * voltage * resonance;
                    apparatus.children[i].material.emissiveIntensity = chargeIntensity;
                    
                    if (chargePhase > 0.8 && chargePhase < 0.9) {
                        apparatus.children[i].scale.setScalar(1.1);
                    } else {
                        apparatus.children[i].scale.setScalar(1);
                    }
                }
            }
        }
        
        // Update UI elements
        function updateUI() {
            const resonance = Math.sin(animationTime * 2) * 0.5 + 0.5;
            document.getElementById('resonance-level').textContent = Math.round(resonance * 100) + '%';
            
            // Update phase based on time
            const phaseTime = animationTime % 24; // 24 second cycle
            if (phaseTime < 8) {
                currentPhase = 'Construction';
            } else if (phaseTime < 16) {
                currentPhase = 'Simulation';
            } else {
                currentPhase = 'Deconstruction';
            }
            document.getElementById('current-phase').textContent = currentPhase;
        }
        
        // Event listeners
        document.getElementById('play-pause').addEventListener('click', function() {
            isPlaying = !isPlaying;
            this.textContent = isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
        });
        
        // Apparatus selection
        ['biefeld-brown', 'flux-capacitor', 'zinsser', 'electrokinetic-saucer'].forEach(apparatus => {
            document.getElementById(apparatus).addEventListener('click', function() {
                currentApparatus = apparatus;
                
                // Update button states
                document.querySelectorAll('#controls button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Update apparatus name
                const names = {
                    'biefeld-brown': 'Biefeld-Brown',
                    'flux-capacitor': 'Flux Capacitor',
                    'zinsser': 'Zinsser Module',
                    'electrokinetic-saucer': 'Electrokinetic Saucer'
                };
                document.getElementById('current-apparatus').textContent = names[apparatus];
            });
        });
        
        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize the application
        init();
    </script>
</body>
</html>